import sqlite3
from typing import Dict, Any
from .db_utils import get_db_connection, row_to_dict

def fallback_sql(sql_query: str) -> Dict[str, Any]:
    """
    Execute SQL query generated by an agent.
    Includes safety checks.

    Args:
        sql_query: SQL query string (This comes from the user and it is the SQL query to be executed): cant be null
        
    Returns:
        Dict with success status and results or error message (success: True/False, error: str)
    """
    try:
        # Safety checks - block dangerous operations
        sql_upper = sql_query.upper().strip()
        
        # Block truly dangerous operations (must be whole words/phrases)
        dangerous_patterns = [
            'DROP TABLE', 'DROP DATABASE', 'TRUNCATE', 'DELETE FROM',
            'ALTER TABLE', 'DROP INDEX', 'CREATE TABLE', 'CREATE INDEX'
        ]
        
        for pattern in dangerous_patterns:
            if pattern in sql_upper:
                return {
                    'success': False,
                    'error': f'Blocked dangerous operation: {pattern}'
                }
        
        
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # Check if the SQL query is a write operation
        is_write = sql_upper.startswith('INSERT') or sql_upper.startswith('UPDATE')
        
        cursor.execute(sql_query)
        
        # If the SQL query is a write operation, commit the changes to the database
        if is_write:
            conn.commit()
            affected_rows = cursor.rowcount
            
            # If the SQL query is an INSERT, return the new id
            if sql_upper.startswith('INSERT'):
                new_id = cursor.lastrowid
                conn.close()
                return {
                    'success': True,
                    'message': f'Inserted with ID {new_id}',
                    'affected_rows': affected_rows,
                    'last_insert_id': new_id
                }
            else:
                # If the SQL query is an UPDATE, return the number of affected rows
                conn.close()
                return {
                    'success': True,
                    'message': f'Updated {affected_rows} row(s)',
                    'affected_rows': affected_rows
                }
        else:  # SELECT
            # If the SQL query is a SELECT, return the results
            rows = cursor.fetchall()
            conn.close()
            
            results = [row_to_dict(row) for row in rows]
            
            return {
                'success': True,
                'results': results,
                'count': len(results)
            }
            
    except sqlite3.Error as e:
        return {
            'success': False,
            'error': f'SQL error: {str(e)}',
            'query': sql_query
        }
    except Exception as e:
        return {
            'success': False,
            'error': f'Error: {str(e)}'
        }